#!/bin/bash
# shellcheck disable=SC2016
set -e
# export PATH="/bin:/usr/bin:/usr/local/bin" # safer, if you can

(( BASH_VERSINFO[0] < 4 )) && echo "Bash 4+ required." && exit 1

: "${PAGER:=more}"
: "${EDITOR:=vi}"
: "${HELP_BROWSER:=}"
: "${EXE:="${0##*/}"}"

declare -A HELP
declare -A CONFIG

_initialize() {
  : "${CONFIG[duration.session]:=25}"
  : "${CONFIG[duration.break.short]:=5}"
  : "${CONFIG[duration.break.long]:=35}"
  : "${CONFIG[sessions.per.block]:=4}"
  : "${CONFIG[mode]:=normal}"
  : "${CONFIG[emoji.on]:=🍅}"
  : "${CONFIG[emoji.off]:=🧘}"
  _config_write
}

HELP[main]='
# Pomodoro Time Manager in Bash

*I just started working on this project.*

## Legal

Copyright 2021 Rob Muhlestein <rob@rwx.gg>  
Released under Apache-2.0 License  
Please mention rwxrob.tv'

help[print]='Prints the current minutes and state as an emoji.'

command_print() {
  [[ -z "${CONFIG[end]}" ]] && return
  local diff
  diff="$(((${CONFIG[end]}-$(date -u +%s))/60))"
  if (( diff > 0 )); then
    echo "${CONFIG[emoji.on]} $diff"
  else
    echo "${CONFIG[emoji.off]} ${diff#-}"
  fi
}

command_duration.session() {
  [[ -z "$1" ]] && echo "${CONFIG[duration.session]}" && return 0
  local dx=$((${CONFIG[duration.session]}-$1))
  _config_set duration.session "$1"
  _config_set end "$((${CONFIG[end]}-(dx*60)))"
}

command_duration.break.short() {
  command_config duration.break.short "$@"
}

command_duration.break.long() {
  command_config duration.break.long "$@"
}

command_sessions.per.block() {
  command_config sessions.per.block "$@"
}

command_emoji.off() {
  command_config emoji.off "$@"
}

command_duration.session() {
  command_config duration.session "$@"
}

command_emoji.on() {
  command_config emoji.on "$@"
}

command_mode() {
  command_config mode "$@"
}

command_duration.break.long() {
  command_config duration.break.long "$@"
}

command_start() {
  _config_set end \
    "$(date -u +%s -d "+ $((${CONFIG[duration.session]}+1)) min")"
}

############################## BOILERPLATE ###########################
## Everything from here to the end of file can be snipped and updated
## with latest from https://github.com/rwxrob/template-bash-command.

# -------------------------- utility command -------------------------

HELP[usage]='Displays a summary of usage.'

command_usage() {
  local -a cmds
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:1} =~ _ ]] && continue
    cmds+=("$c")
  done
  local IFS='|'
  printf "usage: %s (%s)\n" "$EXE" "${cmds[*]}"
}

# --------------------------- help command ---------------------------

HELP[help]='

```
'"$EXE"' help [COMMAND]
```

Displays specific help information. If no argument is passed displays
general help information (main). Otherwise, the documentation for the
specific argument keyword is displayed, which usually corresponds to
a COMMAND name (but not necessarily). All documentation is written in
GitHub Flavored Markdown and will displayed as a web page if `pandoc`
and `$HELP_BROWSER` are detected, otherwise, just the Markdown is sent
to `$PAGER` (default: more).

Also see `readme` and `usage` commands.
'

command_help() { 
  local name="${1:-main}" title body
  title=$(_help_title "$name") || true
  if [[ -z "$title" ]]; then
    body="${HELP[$name]}"
    title="$EXE $name"
    [[ $name = main ]] && title="$EXE"
  else
    body="${HELP[$name]}"
    body=${body#*$title}
  fi
  local file="/tmp/help-$EXE-$name.html"
  if _have pandoc ; then
    if _have "$HELP_BROWSER" && [[ -t 1 ]] ;then
      pandoc -f gfm -s --metadata title="$title" \
        -o "$file" <<< "$body"
      [[ -z "$2" ]] && cd /tmp && exec "$HELP_BROWSER" "$file"
      return 0
    fi
    pandoc -f gfm -s --metadata title="$title" \
      -t plain <<< "$body" | "$PAGER"
    return 0
  fi
  echo -e "$title\n\n$body" | "$PAGER"
}

_help_title() {
  _filter "$@" && return $?;
  local name="$1"
  while IFS= read -r line; do
    [[ $line =~ ^[:space]*$ ]] && continue
    [[ $line =~ ^#\ (.+) ]] && echo "${BASH_REMATCH[1]}" && return 0
    return 1
  done <<< "${HELP[$name]}"
}

# -------------------------- readme command --------------------------

HELP[readme]='
## Generate `README.md` File

```
'"$EXE"' readme > README.md
```

The `readme` command will output the embedded help documentation in raw
GitHub Flavored Markdown suitable for use as a `README.md` file on
GitHub or similar hosting service.'

command_readme() {
  _trim "${HELP[main]}"
  echo
  while IFS= read -r name; do
    [[ $name = main ]] && continue
    body=$(_trim "${HELP[$name]}")
    [[ $body =~ ^\# ]] || body="## The \`$name\` Command"$'\n\n'$body
    printf "%s\n\n" "$body"
  done < <(printf "%s\n" "${!HELP[@]}" | LC_COLLATE=C sort)
  echo -e "----\n\n*Autogenerated $(date)*\n"
}

# -------------------------- config command --------------------------

HELP[config]='

```
'"$EXE"' config
'"$EXE"' config KEY
'"$EXE"' config KEY VALUE
'"$EXE"' config KEY ""
'"$EXE"' config dir
'"$EXE"' config path [file]
'"$EXE"' config edit [file]
```

The `config` command is for reading, writing, and displaying standard
open desktop configuration properties. Pass an empty string to delete
a property.

### Arguments

With no arguments outputs all the currently cached configuration
settings. 

With a single KEY argument fetches the value for that key and outputs
it unless it is one of the following special (reserved) key names:

* `dir` full path to config directory
* `path` full path to specific config file (default: `values`) 
* `edit` opens config file in editor (default: `editor` or `$EDITOR)

With more than one argument the remaining arguments after the KEY will
be combined into the VALUE and written to a `values` file in the
configuration directory. 

### Configuration Directory

The configuration directory path relies on the following environment
variables:

* `EXE` - defaults to name of currently running command ('"$EXE"')
* `HOME` - checked for `$HOME/.config/$EXE/values`
* `XDG_CONFIG_HOME` - overrides `$HOME/.config`
* `CONFIG_DIR` - full path to directory containing `values` file

The `CONFIG_DIR` always takes priority over anything else if set, but is
never implied. If the directory does not exist it will be created the
first time a value is set.

### Configuration `values` File Format

The file (which is almost always located at
`~/.config/'"$EXE"'/values`) uses the simplest possible format to
facilitate standard UNIX parsing and filtering with any number of
existing tools (and no `jq` dependency).

* One KEY=VALUE per line
* KEYs may be anything but the equal sign (`=`)
* VALUEs may be anything but line returns must be escaped

Note that this is *not* the same as Java properties and other similar
format. It is designed for ultimate simplicity, efficiency, and
portability.'

command_config() {
  case $1 in 
    dir)  _config_dir;  return $? ;;
    path) _config_path; return $? ;;
    edit) _config_edit; return $? ;;
  esac
  case $# in
    0) _config_dump ;; 
    1) _config_get "$@" ;;
    *) _config_set "$@" ;;
  esac
}

_config_edit() {
  : "${CONFIG[editor]:="${EDITOR:=vi}"}"
  exec "${CONFIG[editor]}" "$(_config_path "${1:-values}")"
}

_config_dir() {
  local dir="$HOME/.config/$EXE"
  [[ -n "$XDG_CONFIG_HOME" ]] && dir="$XDG_CONFIG_HOME/$EXE" 
  [[ -n "$CONFIG_DIR" ]] && dir="$CONFIG_DIR"
  [[ -n "$1" ]] && echo "$dir/$1" && return 0
  printf "%s" "$dir"
  [[ -t 1 ]] && echo
}

_config_path() { 
  local file=${1:-values}
  printf "%s/%s" "$(_config_dir)" "$file"
  [[ -t 1 ]] && echo
}

_config_set() {
  local key="$1"; shift; local val="$*"
  val="${val//$'\n'/\\n}"
  CONFIG["$key"]="$val"
  _config_write
}

_config_get() { 
  printf "${CONFIG[$1]}"
  [[ -t 1 ]] && echo
}

_config_read() {
  local values="$(_config_path)"
  [[ -r "$values" ]] || return 0
  while IFS= read -r line; do
    [[ $line =~ ^([^=]+)=(.+)$ ]] || continue
    CONFIG["${BASH_REMATCH[1]}"]="${BASH_REMATCH[2]}"
  done < "$values"
}

_config_write() {
  local dir="$(_config_dir)"
  mkdir -p "$dir"
  _config_dump > "$dir/values"
}

_config_dump() {
  (( ${#CONFIG[@]} == 0 )) && return 0
  paste -d=\
    <(printf "%s\n" "${!CONFIG[@]}") \
    <(printf "%s\n" "${CONFIG[@]}")
}

# ----------------------------- utilities ----------------------------

_reduce() {
  local -n name="${1:?"name of array required"}"
  while IFS= read -r key; do
    [[ $key =~ $2 ]] && echo "$key"
  done < <(printf "%s\n" "${name[@]}")
}

_trim() {
  local it="${1#"${1%%[![:space:]]*}"}"
  echo -e "${it%"${it##*[![:space:]]}"}"
}

_have(){ type "$1" &>/dev/null; }

_filter(){
  [[ -n "$1" ]] && return 1
  while IFS= read -ra args; do
    "${FUNCNAME[1]}" "${args[@]}"
  done
}

_buffer() {
  [[ -n "$1" ]] && return 1
  "${FUNCNAME[1]}" "$(</dev/stdin)"
}

# --------------------- completion and delegation --------------------
#         (better than . <(foo bloated_completion) in .bashrc)

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ command_ ]] || continue
  COMMANDS+=( "${line##declare -f command_}" )
done < <(declare -F)
mapfile -t COMMANDS < \
  <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

if [[ -n $COMP_LINE ]]; then
  line=${COMP_LINE#* }
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:${#line}} == "${line,,}" && ${c:0:1} != _ ]] && echo "$c"
  done
  exit
fi

for c in "${COMMANDS[@]}"; do
  if [[ $c == "$EXE" ]]; then
    "command_$EXE" "$@"
    exit $?
  fi
done

_config_read
_initialize

if [[ -n "$1" ]]; then
  declare cmd="$1"; shift
  for c in "${COMMANDS[@]}"; do
    if [[ $c == "$cmd" ]]; then
      "command_$cmd" "$@"
      exit $?
    fi
  done
fi

command_print "$@"
